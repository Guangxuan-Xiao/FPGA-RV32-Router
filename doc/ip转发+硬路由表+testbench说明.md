### 第一个包
包的内容为：``` 0 54 ff ff ff ff ff ff 54 45 53 54 5f 30 08 00 45 00 00 28 b0 1a 00 00 40 11 fe ff 0a 00 00 02 bb bb bb bb 00 07 00 07 00 14 6f 75 68 65 6c 6c 6f 2c 20 30 30 30 30 39 ```

其中```0```为端口号，```54```为此后的数据长度，这些内容不纳入以太网帧。```ff ff ff ff ff ff```为目标MAC地址，```54 45 53 54 5f 30```为源MAC地址，然后```08 00```为IP协议类型，这几个字段都是位于以太网帧的头部的。然后以下内容是在IP头的：```45```为版本以及首部长度，```00```为服务类型，```00 28```为长度，```b0 1a```为认证，```00 00```为标志以及段偏移量，```40```为TTL，```11```为协议（此处11代表UDP），```fe ff```为校验和，```0a 00 00 02```为源IP地址，```bb bb bb bb```为目的IP地址，剩下的东西为数据填充，忽略。

因此，工作原理如下，在收到这个包的时候，由于ARP缓存表为空，因此无法在ARP缓存表中获取相应的表项，按照规则，此时应当发出一个arp的申请，则有arp包的结构如下所示：```0 42 ff ff ff ff ff ff 80 aa aa aa aa 10 08 06 00 01 08 00 06 04 00 01 80 aa aa aa aa 10 aa aa aa 00 ff ff ff ff ff ff bb bb bb bb```

其中```ff ff ff ff ff ff```为组播地址，```80 aa aa aa aa 10```为本端口对应的MAC地址，此后都是常数不再赘述，其中```00 01```代表Request请求。```80 aa aa aa 10 aa aa aa 00```代表了当前端口的MAC地址以及IP地址，并且```ff ff ff ff ff ff bb bb bb bb```代表目的待确定的MAC地址以及其IP地址。

### 第二个包
那么第二个包应该为ARP的回复包，其内容为：```0 42 80 aa aa aa aa 10 12 34 56 78 9a bc 08 06 00 01 08 00 06 04 00 02 12 34 56 78 9a bc bb bb bb bb 80 aa aa aa aa 10 aa aa aa 00```

其中发生改变的位置为：```80 aa aa aa aa 10```以及```54 45 53 54 5f 30```分别为目标端口的MAC地址以及源地址的MAC地址，```00 02```代表Reply，```12 34 56 78 9a bc bb bb bb bb```为现在源的MAC以及IP，而```80 aa aa aa aa 10 aa aa aa 00```为原来申请者的MAC和IP。

因此，如此发包，那么这个ARP包会在丢包之前被记录进ARP缓存表。

### 第三个包
第三个包和第一个包完全相同：``` 0 54 ff ff ff ff ff ff 54 45 53 54 5f 30 08 00 45 00 00 28 b0 1a 00 00 40 11 fe ff 0a 00 00 02 bb bb bb bb 00 07 00 07 00 14 6f 75 68 65 6c 6c 6f 2c 20 30 30 30 30 39 ```

但是此时```bb bb bb bb```作为目的IP地址已经存入了ARP缓存表中了，所以此时应当可以查到对应的MAC地址```12 34 56 78 9a bc```，因此最后发出的包应当为：```1 54 12 34 56 78 9a bc 80 aa aa aa aa 10 08 00 45 00 00 28 b0 1a 00 00 40 11 fe ff 0a 00 00 02 bb bb bb bb 00 07 00 07 00 14 6f 75 68 65 6c 6c 6f 2c 20 30 30 30 30 39 ```

### 仿真结果
若不考虑数据段，则目前所有仿真内容完全吻合，没有任何错误。